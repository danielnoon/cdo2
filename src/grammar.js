// Generated automatically by nearley, version 2.20.1
// http://github.com/Hardmath123/nearley
(function () {
function id(x) { return x[0]; }

  const moo = require("moo")
  const lexer = moo.compile({
    string: { match: /"(?:\\["bfnrt\/\\]|\\u[a-fA-F0-9]{4}|[^"\\])*"/, value: x => x.slice(1, -1) },
    nl: { match: [/\n/,/\r\n/], lineBreaks: true },
    ws: /[ \t]+/,
    and: 'and',
    or: 'or',
    not: 'not',
    // fn: 'fn',
    // actor: 'actor',
    // times: 'times',
    boolean: { match: ['true', 'false'], value: x => x === 'true' },
    number: {
      match: [/[-]?[0-9]+\.?[0-9]*/, "infinity", "-infinity"],
      value: x => ["infinity", "-infinity"].includes(x) ? x : parseFloat(x, 10)
    },
    id: /[A-Za-z_\$][\$A-Za-z0-9_]*/,
    dot: /\./,
    lparen:  '(',
    rparen:  ')',
    assignment: '->',
    define: ':=',
    reassign: '<-',
    add: '+',
    sub: '-',
    mul: '*',
    div: '/',
    pow: '^',
    mod: '%',
    lbrace: '{',
    rbrace: '}',
    call: '@',
    gte: '>=',
    lte: '<=',
    gt: '>',
    lt: '<',
    neq: '!=',
    eq: '=',
    lbrack: '[',
    rbrack: ']',
    comma: ',',
    colon: ':'
  });


  const escapes = {
    n: '\n',
    r: '\r',
    t: '\t',
    b: '\b',
    '"': '"',
    "'": "'",
    "\\": "\\"
  }
  function escapeString(str) {
    return str.replace(/\\(\\|n|b|"|'|t|r)/g, ([,char]) => escapes[char])
  }
var grammar = {
    Lexer: lexer,
    ParserRules: [
    {"name": "main", "symbols": ["scriptBody"], "postprocess": id},
    {"name": "__", "symbols": [(lexer.has("ws") ? {type: "ws"} : ws)], "postprocess": id},
    {"name": "_", "symbols": ["__"], "postprocess": id},
    {"name": "_", "symbols": [], "postprocess": id},
    {"name": "___$ebnf$1", "symbols": []},
    {"name": "___$ebnf$1$subexpression$1", "symbols": ["__"]},
    {"name": "___$ebnf$1$subexpression$1", "symbols": ["NL"]},
    {"name": "___$ebnf$1", "symbols": ["___$ebnf$1", "___$ebnf$1$subexpression$1"], "postprocess": function arrpush(d) {return d[0].concat([d[1]]);}},
    {"name": "___", "symbols": ["___$ebnf$1"]},
    {"name": "ID", "symbols": [(lexer.has("id") ? {type: "id"} : id)], "postprocess": id},
    {"name": "ASSIGN", "symbols": [(lexer.has("assignment") ? {type: "assignment"} : assignment)], "postprocess": id},
    {"name": "NL", "symbols": [(lexer.has("nl") ? {type: "nl"} : nl)], "postprocess": id},
    {"name": "DOT", "symbols": [(lexer.has("dot") ? {type: "dot"} : dot)], "postprocess": id},
    {"name": "STRING", "symbols": [(lexer.has("string") ? {type: "string"} : string)], "postprocess": id},
    {"name": "NUMBER", "symbols": [(lexer.has("number") ? {type: "number"} : number)], "postprocess": id},
    {"name": "DEFINE", "symbols": [(lexer.has("define") ? {type: "define"} : define)], "postprocess": id},
    {"name": "REASSIGN", "symbols": [(lexer.has("reassign") ? {type: "reassign"} : reassign)], "postprocess": id},
    {"name": "ADD", "symbols": [(lexer.has("add") ? {type: "add"} : add)], "postprocess": id},
    {"name": "SUB", "symbols": [(lexer.has("sub") ? {type: "sub"} : sub)], "postprocess": id},
    {"name": "MUL", "symbols": [(lexer.has("mul") ? {type: "mul"} : mul)], "postprocess": id},
    {"name": "DIV", "symbols": [(lexer.has("div") ? {type: "div"} : div)], "postprocess": id},
    {"name": "POW", "symbols": [(lexer.has("pow") ? {type: "pow"} : pow)], "postprocess": id},
    {"name": "MOD", "symbols": [(lexer.has("mod") ? {type: "mod"} : mod)], "postprocess": id},
    {"name": "LPAREN", "symbols": [(lexer.has("lparen") ? {type: "lparen"} : lparen)], "postprocess": id},
    {"name": "RPAREN", "symbols": [(lexer.has("rparen") ? {type: "rparen"} : rparen)], "postprocess": id},
    {"name": "LBRACE", "symbols": [(lexer.has("lbrace") ? {type: "lbrace"} : lbrace)], "postprocess": id},
    {"name": "RBRACE", "symbols": [(lexer.has("rbrace") ? {type: "rbrace"} : rbrace)], "postprocess": id},
    {"name": "CALL", "symbols": [(lexer.has("call") ? {type: "call"} : call)], "postprocess": id},
    {"name": "GTE", "symbols": [(lexer.has("gte") ? {type: "gte"} : gte)], "postprocess": id},
    {"name": "LTE", "symbols": [(lexer.has("lte") ? {type: "lte"} : lte)], "postprocess": id},
    {"name": "GT", "symbols": [(lexer.has("gt") ? {type: "gt"} : gt)], "postprocess": id},
    {"name": "LT", "symbols": [(lexer.has("lt") ? {type: "lt"} : lt)], "postprocess": id},
    {"name": "NEQ", "symbols": [(lexer.has("neq") ? {type: "neq"} : neq)], "postprocess": id},
    {"name": "EQ", "symbols": [(lexer.has("eq") ? {type: "eq"} : eq)], "postprocess": id},
    {"name": "LBRACK", "symbols": [(lexer.has("lbrack") ? {type: "lbrack"} : lbrack)], "postprocess": id},
    {"name": "RBRACK", "symbols": [(lexer.has("rbrack") ? {type: "rbrack"} : rbrack)], "postprocess": id},
    {"name": "AND", "symbols": [(lexer.has("and") ? {type: "and"} : and)], "postprocess": id},
    {"name": "OR", "symbols": [(lexer.has("or") ? {type: "or"} : or)], "postprocess": id},
    {"name": "NOT", "symbols": [(lexer.has("not") ? {type: "not"} : not)], "postprocess": id},
    {"name": "COMMA", "symbols": [(lexer.has("comma") ? {type: "comma"} : comma)], "postprocess": id},
    {"name": "BOOL", "symbols": [(lexer.has("boolean") ? {type: "boolean"} : boolean)], "postprocess": id},
    {"name": "COLON", "symbols": [(lexer.has("colon") ? {type: "colon"} : colon)], "postprocess": id},
    {"name": "body", "symbols": ["line", "___", "body"], "postprocess": ([i,, b]) => [i, ...b]},
    {"name": "body", "symbols": ["line"], "postprocess": ([i]) => [i]},
    {"name": "scriptBody", "symbols": ["actor", "___", "scriptBody"], "postprocess": ([act,,body]) => [act, ...body]},
    {"name": "scriptBody", "symbols": ["line", "___", "scriptBody"], "postprocess": ([line,,body]) => [line, ...body]},
    {"name": "scriptBody", "symbols": ["actor"], "postprocess": ([act]) => [act]},
    {"name": "scriptBody", "symbols": ["line"], "postprocess": ([line]) => [line]},
    {"name": "actor", "symbols": [{"literal":"actor"}, "__", "ID", "__", "LBRACE", "___", "actorBody", "___", "RBRACE"], "postprocess": ([,,name,,,,body]) => ({ type: 'ACTOR', name, body})},
    {"name": "actorBody", "symbols": ["assignment", "___", "actorBody"], "postprocess": ([a,,as]) => [a, ...as]},
    {"name": "actorBody", "symbols": ["assignment"], "postprocess": ([a]) => [a]},
    {"name": "expression", "symbols": ["or"], "postprocess": id},
    {"name": "expression", "symbols": ["expression", "__", {"literal":"times"}], "postprocess": ([n]) => ({ type: "TIMES", number: n })},
    {"name": "expression", "symbols": ["func"], "postprocess": id},
    {"name": "expression", "symbols": ["invoke"], "postprocess": id},
    {"name": "expression", "symbols": ["getter"], "postprocess": id},
    {"name": "invoke", "symbols": [{"literal":"DO"}, "__", "expression", "__", "args"], "postprocess": ([,,expr,,args]) => ({ type: "CALL", expr, args })},
    {"name": "invoke", "symbols": [{"literal":"DO"}, "__", "expression"], "postprocess": ([,,expr]) =>       ({ type: "CALL", expr, args: null })},
    {"name": "or", "symbols": ["or", "_", "OR", "_", "and"], "postprocess": ([left,, op,, right]) => ({ type: "LOGICAL", left, op: "OR", right })},
    {"name": "or", "symbols": ["and"], "postprocess": id},
    {"name": "and", "symbols": ["and", "_", "AND", "_", "equality"], "postprocess": ([left,, op,, right]) => ({ type: "LOGICAL", left, op: "AND", right })},
    {"name": "and", "symbols": ["equality"], "postprocess": id},
    {"name": "equality", "symbols": ["equality", "_", "EQ", "_", "comp"], "postprocess": ([left,, op,, right]) => ({ type: "COMP", left, op: "EQ", right })},
    {"name": "equality", "symbols": ["equality", "_", "NEQ", "_", "comp"], "postprocess": ([left,, op,, right]) => ({ type: "COMP", left, op: "NEQ", right })},
    {"name": "equality", "symbols": ["comp"], "postprocess": id},
    {"name": "comp", "symbols": ["comp", "_", "GTE", "_", "addsub"], "postprocess": ([left,, op,, right]) => ({ type: "COMP", left, op: "GTE", right })},
    {"name": "comp", "symbols": ["comp", "_", "GT", "_", "addsub"], "postprocess": ([left,, op,, right]) => ({ type: "COMP", left, op: "GT", right })},
    {"name": "comp", "symbols": ["comp", "_", "LTE", "_", "addsub"], "postprocess": ([left,, op,, right]) => ({ type: "COMP", left, op: "LTE", right })},
    {"name": "comp", "symbols": ["comp", "_", "LT", "_", "addsub"], "postprocess": ([left,, op,, right]) => ({ type: "COMP", left, op: "LT", right })},
    {"name": "comp", "symbols": ["addsub"], "postprocess": id},
    {"name": "math", "symbols": ["addsub"], "postprocess": id},
    {"name": "addsub", "symbols": ["addsub", "_", "ADD", "_", "muldiv"], "postprocess": ([left,, op,, right]) => ({ type: "ARITH", left, op: "ADD", right })},
    {"name": "addsub", "symbols": ["addsub", "_", "SUB", "_", "muldiv"], "postprocess": ([left,, op,, right]) => ({ type: "ARITH", left, op: "SUB", right })},
    {"name": "addsub", "symbols": ["muldiv"], "postprocess": id},
    {"name": "muldiv", "symbols": ["muldiv", "_", "MUL", "_", "pow"], "postprocess": ([left,, op,, right]) => ({ type: "ARITH", left, op: "MUL", right })},
    {"name": "muldiv", "symbols": ["muldiv", "_", "DIV", "_", "pow"], "postprocess": ([left,, op,, right]) => ({ type: "ARITH", left, op: "DIV", right })},
    {"name": "muldiv", "symbols": ["muldiv", "_", "MOD", "_", "pow"], "postprocess": ([left,, op,, right]) => ({ type: "ARITH", left, op: "MOD", right })},
    {"name": "muldiv", "symbols": ["pow"], "postprocess": id},
    {"name": "pow", "symbols": ["group", "_", "POW", "_", "pow"], "postprocess": ([left,, op,, right]) => ({ type: "ARITH", left, op: "POW", right })},
    {"name": "pow", "symbols": ["group"], "postprocess": id},
    {"name": "pow", "symbols": ["group"], "postprocess": id},
    {"name": "group", "symbols": ["LPAREN", "_", "expression", "_", "RPAREN"], "postprocess": ([,,exp]) => exp},
    {"name": "group", "symbols": ["literal"], "postprocess": id},
    {"name": "group", "symbols": ["ID"], "postprocess": id},
    {"name": "group", "symbols": ["selector"], "postprocess": id},
    {"name": "operand", "symbols": ["expression"], "postprocess": id},
    {"name": "getter", "symbols": ["ID", "_", "DOT", "_", "ID"], "postprocess": ([actor,,,,action]) => ({ type: "GETTER", actor, action })},
    {"name": "func$ebnf$1", "symbols": []},
    {"name": "func$ebnf$1$subexpression$1", "symbols": ["__", "parameter"], "postprocess": ([,p]) => p},
    {"name": "func$ebnf$1", "symbols": ["func$ebnf$1", "func$ebnf$1$subexpression$1"], "postprocess": function arrpush(d) {return d[0].concat([d[1]]);}},
    {"name": "func", "symbols": [{"literal":"fn"}, "func$ebnf$1", "_", "LBRACE", "fbody", "RBRACE"], "postprocess": ([,params,,,body]) => ({ type: 'FUNCTION', params, body })},
    {"name": "fbody", "symbols": ["___", "body", "___"], "postprocess": ([,body]) => ({ type: 'FUNCBODY', body })},
    {"name": "fbody", "symbols": ["___", "expression", "___"], "postprocess": ([,body]) => ({ type: 'FUNCEXPR', body })},
    {"name": "parameter", "symbols": ["ID"], "postprocess": id},
    {"name": "parameter", "symbols": ["unpack"], "postprocess": id},
    {"name": "parameter", "symbols": [{"literal":"?"}, "_", "ID"], "postprocess": ([,id]) => ({ type: "OPTIONAL_PARAM", name: id })},
    {"name": "line", "symbols": ["instruction"], "postprocess": id},
    {"name": "line", "symbols": ["assignment"], "postprocess": id},
    {"name": "line", "symbols": ["reassignment"], "postprocess": id},
    {"name": "line", "symbols": ["invoke"], "postprocess": id},
    {"name": "line", "symbols": ["ifStatement"], "postprocess": id},
    {"name": "assignment$subexpression$1", "symbols": ["ID"]},
    {"name": "assignment$subexpression$1", "symbols": ["selector"]},
    {"name": "assignment$subexpression$1", "symbols": ["unpack"]},
    {"name": "assignment", "symbols": ["assignment$subexpression$1", "_", "DEFINE", "_", "expression"], "postprocess": ([dest,,,, expr]) => ({ type: "ASSIGNMENT", dest: dest[0], value: expr })},
    {"name": "reassignment$subexpression$1", "symbols": ["ID"]},
    {"name": "reassignment$subexpression$1", "symbols": ["selector"]},
    {"name": "reassignment$subexpression$1", "symbols": ["unpack"]},
    {"name": "reassignment", "symbols": ["reassignment$subexpression$1", "_", "REASSIGN", "_", "expression"], "postprocess": ([dest,,,, expr]) => ({ type: "REASSIGNMENT", dest: dest[0], value: expr })},
    {"name": "instruction", "symbols": ["call", "_", "ASSIGN", "_", "ID"], "postprocess": ([call,,,, assign]) => ({ type: 'INSTRUCTION', ...call, assign})},
    {"name": "instruction", "symbols": ["call"], "postprocess": ([call]) => ({ type: 'INSTRUCTION', ...call, assign: null})},
    {"name": "call", "symbols": ["command", "__", "args"], "postprocess": ([command,, args]) => ({...command, args})},
    {"name": "call", "symbols": ["command"], "postprocess": ([command]) => ({...command, args: []})},
    {"name": "command", "symbols": ["ID", "_", "DOT", "_", {"literal":"DO"}, "_", "DOT", "_", "ID"], "postprocess": ([actor,,,,,,,, action]) => ({actor, action})},
    {"name": "unpack", "symbols": ["unpackList"], "postprocess": id},
    {"name": "unpackList$subexpression$1", "symbols": ["ID"]},
    {"name": "unpackList$subexpression$1", "symbols": ["selector"], "postprocess": id},
    {"name": "unpackList$ebnf$1", "symbols": []},
    {"name": "unpackList$ebnf$1$subexpression$1$subexpression$1", "symbols": ["ID"]},
    {"name": "unpackList$ebnf$1$subexpression$1$subexpression$1", "symbols": ["selector"], "postprocess": id},
    {"name": "unpackList$ebnf$1$subexpression$1", "symbols": ["COMMA", "___", "unpackList$ebnf$1$subexpression$1$subexpression$1"], "postprocess": ([,,id]) => id},
    {"name": "unpackList$ebnf$1", "symbols": ["unpackList$ebnf$1", "unpackList$ebnf$1$subexpression$1"], "postprocess": function arrpush(d) {return d[0].concat([d[1]]);}},
    {"name": "unpackList", "symbols": ["LBRACK", "___", "unpackList$subexpression$1", "_", "unpackList$ebnf$1", "RBRACK"], "postprocess": ([,,id,,rest]) => ({ type: "UNPACK", ids: [id, ...rest].map(([el]) => el)})},
    {"name": "listLiteral", "symbols": ["LBRACK", "___", "listBody", "___", "RBRACK"], "postprocess": ([,,elements]) => ({ type: "LIST", elements })},
    {"name": "listLiteral", "symbols": ["LBRACK", "_", "RBRACK"], "postprocess": () => ({ type: "LIST", elements: [] })},
    {"name": "listBody", "symbols": ["expression", "_", "COMMA", "___", "listBody"], "postprocess": ([expr,,,,body]) => [expr, ...body]},
    {"name": "listBody", "symbols": ["expression"], "postprocess": ([expr]) => [expr]},
    {"name": "dictLiteral", "symbols": ["LBRACE", "___", "dictBody", "___", "RBRACE"], "postprocess": ([,,entries]) => ({ type: "DICT", entries })},
    {"name": "dictLiteral", "symbols": ["LBRACE", "_", "RBRACE"], "postprocess": () => ({ type: "DICT", entries: [] })},
    {"name": "dictBody", "symbols": ["dictEntry", "_", "COMMA", "___", "dictBody"], "postprocess": ([entry,,,,body]) => [entry, ...body]},
    {"name": "dictBody", "symbols": ["dictEntry"], "postprocess": ([e]) => [e]},
    {"name": "dictEntry", "symbols": ["dictKey", "_", "COLON", "_", "expression"], "postprocess": ([key,,,,value]) => ({ key, value })},
    {"name": "dictKey", "symbols": ["LBRACK", "_", "expression", "_", "RBRACK"], "postprocess": ([,,expr]) => expr},
    {"name": "dictKey", "symbols": ["STRING"], "postprocess": id},
    {"name": "literal", "symbols": ["STRING"], "postprocess": ([str]) => ({...str, value: escapeString(str.value)})},
    {"name": "literal", "symbols": ["NUMBER"], "postprocess": id},
    {"name": "literal", "symbols": ["listLiteral"], "postprocess": id},
    {"name": "literal", "symbols": ["BOOL"], "postprocess": id},
    {"name": "literal", "symbols": ["dictLiteral"], "postprocess": id},
    {"name": "ifStatement$ebnf$1", "symbols": ["__"], "postprocess": id},
    {"name": "ifStatement$ebnf$1", "symbols": [], "postprocess": function(d) {return null;}},
    {"name": "ifStatement$ebnf$2", "symbols": ["elseStatement"], "postprocess": id},
    {"name": "ifStatement$ebnf$2", "symbols": [], "postprocess": function(d) {return null;}},
    {"name": "ifStatement", "symbols": [{"literal":"if"}, "__", "expression", "__", {"literal":"DO"}, "___", "LBRACE", "___", "body", "___", "RBRACE", "ifStatement$ebnf$1", "ifStatement$ebnf$2"], "postprocess": ([,,test,,,,,,body,,,,els]) => ({ type: "CONDITIONAL", test, body, else: els })},
    {"name": "ifStatement$ebnf$3", "symbols": ["__"], "postprocess": id},
    {"name": "ifStatement$ebnf$3", "symbols": [], "postprocess": function(d) {return null;}},
    {"name": "ifStatement$ebnf$4", "symbols": ["elseStatement"], "postprocess": id},
    {"name": "ifStatement$ebnf$4", "symbols": [], "postprocess": function(d) {return null;}},
    {"name": "ifStatement", "symbols": [{"literal":"if"}, "__", "expression", "__", {"literal":"DO"}, "__", "expression", "ifStatement$ebnf$3", "ifStatement$ebnf$4"], "postprocess": ([,,test,,,,expr]) =>   ({ type: "CONDITIONAL", test, body: expr })},
    {"name": "elseStatement", "symbols": [{"literal":"else"}, "__", "ifStatement"], "postprocess": ([,,iff]) => iff},
    {"name": "elseStatement", "symbols": [{"literal":"else"}, "__", {"literal":"DO"}, "___", "expression"], "postprocess": ([,,,,expr]) => ({ type: "ELSE", body: expr })},
    {"name": "elseStatement", "symbols": [{"literal":"else"}, "__", {"literal":"DO"}, "___", "LBRACE", "___", "body", "___", "RBRACE"], "postprocess": ([,,,,,,body]) => ({ type: "ELSE", body })},
    {"name": "selector", "symbols": ["expression", "LBRACK", "_", "expression", "_", "RBRACK"], "postprocess": ([base,,,expr]) => ({ type: "SELECTOR", base, expr })},
    {"name": "arg", "symbols": ["literal"], "postprocess": id},
    {"name": "arg", "symbols": ["ID"], "postprocess": id},
    {"name": "arg", "symbols": ["LPAREN", "_", "expression", "_", "RPAREN"], "postprocess": ([,,expr]) => expr},
    {"name": "arg", "symbols": ["selector"], "postprocess": id},
    {"name": "args", "symbols": ["arg", "__", "args"], "postprocess": ([arg,, args]) => [arg, ...args]},
    {"name": "args", "symbols": ["arg"], "postprocess": ([arg]) => [arg]}
]
  , ParserStart: "main"
}
if (typeof module !== 'undefined'&& typeof module.exports !== 'undefined') {
   module.exports = grammar;
} else {
   window.grammar = grammar;
}
})();
